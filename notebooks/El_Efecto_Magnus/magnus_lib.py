import sys
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from IPython.display import HTML

𝜋 = np.pi

def plotGrid(xm, ym, size, frame='grid'):
    Lx = xm[-1] - xm[0]
    Ly = ym[-1] - ym[0]
    plt.figure(figsize=(size, (Ly)/(Lx)*size))

    if frame == 'grid':
        for y in ym:
            plt.plot([xm[0],xm[-1]], [y,y], color = 'gray', ls = '-', lw = 0.5)
        for x in xm:
            plt.plot([x,x], [ym[0],ym[-1]], color = 'gray', ls = '-', lw = 0.5)
    elif frame == 'box':
        plt.plot([xm[0],xm[0]], [ym[0],ym[-1]], color = 'k', ls = '-', lw = 0.5)
        plt.plot([xm[-1],xm[-1]], [ym[0],ym[-1]], color = 'k', ls = '-', lw = 0.5)
        plt.plot([xm[0],xm[-1]], [ym[0],ym[0]], color = 'k', ls = '-', lw = 0.5)
        plt.plot([xm[0],xm[-1]], [ym[-1],ym[-1]], color = 'k', ls = '-', lw = 0.5)
    elif frame == 'topdown':
        plt.plot([xm[0],xm[-1]], [ym[0],ym[0]], color = 'k', ls = '-', lw = 0.5)
        plt.plot([xm[0],xm[-1]], [ym[-1],ym[-1]], color = 'k', ls = '-', lw = 0.5)
        
    axes = plt.gca()
    axes.set_aspect('equal')
    lmin = min(Lx, Ly)
    offx = lmin * 0.1
    offy = lmin * 0.1
    ax = xm[0]
    bx = xm[-1]
    ay = ym[0]
    by = ym[-1]
    axes.set_xlim(ax-offx, bx+offx)
    axes.set_ylim(ay-offy, by+offy)
    axes.set_xlabel('x', fontsize=20)
    axes.set_ylabel('y', fontsize=20)
    axes.spines.left.set_visible(True)
    axes.spines.right.set_visible(False)
    axes.spines.top.set_visible(False)
    axes.spines.bottom.set_visible(True)

    return axes

#-----------------------------

def get_velocity_doublet(𝜅, xd, yd, xg, yg):
    """Returns the velocity field generated by a doublet.
    
    Arguments
    ---------
    𝜅 -- strength of the doublet.
    xd, yd -- coordinates of the doublet.
    X, Y -- mesh grid.
    """
    u = - 𝜅 /(2 * 𝜋) *((xg-xd)**2-(yg-yd)**2) / ((xg-xd)**2+(yg-yd)**2)**2
    v = - 𝜅 /(2 * 𝜋) * 2*(xg-xd)*(yg-yd) / ((xg-xd)**2+(yg-yd)**2)**2
    
    return u, v

def get_stream_function_doublet(strength, xd, yd, xg, yg):
    """Returns the stream-function generated by a doublet.
    
    Arguments
    ---------
    strength -- strength of the doublet.
    xd, yd -- coordinates of the doublet.
    X, Y -- mesh grid.
    """
    psi = - strength/(2*np.pi)*(yg-yd)/((xg-xd)**2+(yg-yd)**2)
    
    return psi

def get_velocity_vortex(Γ, xv, yv, xg, yg):
    """Returns the velocity field generated by a vortex.
    
    Arguments
    ---------
    strength -- strength of the vortex.
    xv, yv -- coordinates of the vortex.
    X, Y -- mesh grid.
    """
    u = + Γ/(2*𝜋)*(yg-yv)/((xg-xv)**2+(yg-yv)**2)
    v = - Γ/(2*𝜋)*(xg-xv)/((xg-xv)**2+(yg-yv)**2)
    return u, v

def get_stream_function_vortex(Γ, xv, yv, xg, yg):
    """Returns the stream-function generated by a vortex.
    
    Arguments
    ---------
    strength -- strength of the vortex.
    xv, yv -- coordinates of the vortex.
    X, Y -- mesh grid.
    """
    psi = Γ/(4*𝜋)*np.log((xg-xv)**2+(yg-yv)**2)
    
    return psi

def cylinder_definition(𝛼):
    xd1, yd1 = 0.75 * np.cos(𝛼 + 𝜋), 0.75 * np.sin(𝛼 + 𝜋)
    xd2, yd2 = 0.75 * np.cos(𝛼 + 𝜋/2), 0.75 * np.sin(𝛼 + 𝜋/2)
    xd3, yd3 = 0.75 * np.cos(𝛼), 0.75 * np.sin(𝛼)     
    xd4, yd4 = 0.75 * np.cos(𝛼 - 𝜋/2), 0.75 * np.sin(𝛼 - 𝜋/2)
    return [(xd1, yd1), (xd2, yd2), (xd3, yd3), (xd4, yd4)]

def stream_function(𝛼, 𝜅, 𝑢_inf, Γ, num_cil, xg, yg, kind):
    cc = cylinder_definition(𝛼)

    if kind == 'Streamplot':
        # Computes the velocity field on the mesh grid
        u_d1, v_d1 = get_velocity_doublet(𝜅, cc[0][0], cc[0][1], xg, yg)
        u_d2, v_d2 = get_velocity_doublet(𝜅, cc[1][0], cc[1][1], xg, yg)
        u_d3, v_d3 = get_velocity_doublet(𝜅, cc[2][0], cc[2][1], xg, yg)
        u_d4, v_d4 = get_velocity_doublet(𝜅, cc[3][0], cc[3][1], xg, yg)

        # computes the velocity field on the mesh grid
        u_v1, v_v1 = get_velocity_vortex(Γ, cc[0][0], cc[0][1], xg, yg)
        u_v2, v_v2 = get_velocity_vortex(Γ, cc[1][0], cc[1][1], xg, yg)
        u_v3, v_v3 = get_velocity_vortex(Γ, cc[2][0], cc[2][1], xg, yg)
        u_v4, v_v4 = get_velocity_vortex(Γ, cc[3][0], cc[3][1], xg, yg)

        u_freestream = 𝑢_inf * np.ones(xg.shape, dtype=float)
        v_freestream = np.zeros(xg.shape, dtype=float)
        # Superposition of the doublet on the freestream flow
        u1 = u_freestream + u_d1 + u_v1
        v1 = v_freestream + v_d1 + v_v1
        u2 = u_freestream + u_d2 + u_v2
        v2 = v_freestream + v_d2 + v_v2
        u3 = u_freestream + u_d3 + u_v2
        v3 = v_freestream + v_d3 + v_v3
        u4 = u_freestream + u_d4 + u_v4
        v4 = v_freestream + v_d4 + v_v4
        
        if num_cil == 1:
            u_sum = u1
            v_sum = v1
        elif num_cil == 2:
            u_sum = u1 + u2
            v_sum = v1 + v2
        elif num_cil == 3:
            u_sum = u1 + u2 + u3
            v_sum = v1 + v2 + v3
        elif num_cil == 4:
            u_sum = u1 + u2 + u3 + u4
            v_sum = v1 + v2 + v3 + v4
            
        return u_sum, v_sum
    
    elif kind == 'Streamfunction':
        psi_freestream = 𝑢_inf * yg 
        # computes the stream-function on the mesh grid
        p1 = psi_freestream + get_stream_function_doublet(𝜅, cc[0][0], cc[0][1], xg, yg)
        p2 = psi_freestream + get_stream_function_doublet(𝜅, cc[1][0], cc[1][1], xg, yg)
        p3 = psi_freestream + get_stream_function_doublet(𝜅, cc[2][0], cc[2][1], xg, yg)
        p4 = psi_freestream + get_stream_function_doublet(𝜅, cc[3][0], cc[3][1], xg, yg)

        p1_v = get_stream_function_vortex(Γ, cc[0][0], cc[0][1], xg, yg)
        p2_v = get_stream_function_vortex(Γ, cc[1][0], cc[1][1], xg, yg)
        p3_v = get_stream_function_vortex(Γ, cc[2][0], cc[2][1], xg, yg)
        p4_v = get_stream_function_vortex(Γ, cc[3][0], cc[3][1], xg, yg)

        if num_cil == 1:
            s_f = p1+p1_v
        elif num_cil == 2:
            s_f = p1+p1_v + p2+p2_v
        elif num_cil == 3:
            s_f = p1+p1_v + p2+p2_v + p3+p3_v
        elif num_cil == 4:
            s_f = p1+p1_v + p2+p2_v + p3+p3_v + p4+p4_v
    
        return s_f
    

def mi_animacion(x, y, i=0, 𝜅=0.25, Γ=0.0, num_cil=1, kind='Streamfunction'):
    𝛼 = 𝜋 * 8 * i / 90
    𝑢_inf = 0.6      # Velocidad del flujo libre

    cc = cylinder_definition(𝛼)

    xg, yg = np.meshgrid(x, y)            # Malla del dominio
    size = 8
    # Initialization of figure
    ax = plotGrid(x, y, size,'topdown')

    if kind == 'Streamplot':
        u_f, v_f = stream_function(𝛼, 𝜅, 𝑢_inf, Γ, num_cil, xg, yg, kind)
        ax.streamplot(xg, yg, u_f, v_f, density=1.0, linewidth=0.75, color='#2e86c1', arrowsize=0.75, minlength=0.8)
    elif kind == 'Streamfunction':
        s_f = stream_function(𝛼, 𝜅, 𝑢_inf, Γ, num_cil, xg, yg, kind)
        ax.contour(xg, yg, s_f, levels=100, colors='#9b59b6', 
                   linewidths=0.75, linestyles='solid')

    R = np.sqrt(𝜅 / (4 * 𝜋 * 𝑢_inf))                  # Radio
    
    circ1 = plt.Circle(cc[0], radius=R, fc='C1', ec='k', alpha=0.5)
    circ2 = plt.Circle(cc[1], radius=R, fc='C2', ec='k', alpha=0.5)
    circ3 = plt.Circle(cc[2], radius=R, fc='C3', ec='k', alpha=0.5)
    circ4 = plt.Circle(cc[3], radius=R, fc='C4', ec='k', alpha=0.5)
    
    if num_cil == 1:
        ax.add_patch(circ1)
    elif num_cil == 2:
        ax.add_patch(circ1)
        ax.add_patch(circ2)
    elif num_cil == 3:
        ax.add_patch(circ1)
        ax.add_patch(circ2)
        ax.add_patch(circ3)
    elif num_cil == 4:
        ax.add_patch(circ1)
        ax.add_patch(circ2)
        ax.add_patch(circ3) 
        ax.add_patch(circ4)
        
if __name__ == '__main__':

    𝜅 = 0.25         # fuerza del of the doublet
    𝛼 = 0
    Γ = 4.0
    # Dimensiones del dominio
    x_start, x_end = -2.0, 2.0  
    y_start, y_end = -1.0, 1.0 

    N = 200                               # Número de puntos discretos
    x = np.linspace(x_start, x_end, N)    # Arreglo 1D en x
    y = np.linspace(y_start, y_end, N)    # Arreglo 1D en y

    num_cil = 1
    mi_animacion(x, y, 0, 𝜅, Γ, num_cil,  kind='Streamfunction')

    plt.show()